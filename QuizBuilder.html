<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Quiz Builder (Trainer)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Mammoth for DOCX parsing -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.4.2/mammoth.browser.min.js"></script>

  <style>
    * { box-sizing: border-box; font-family: system-ui, sans-serif; }
    body {
      margin: 0; padding: 0; background: #f3f4f6;
      min-height: 100vh; display: flex; align-items: center; justify-content: center;
    }
    .app {
      width: 95%; max-width: 1100px;
      background: white; border-radius: 16px;
      padding: 20px;
      box-shadow: 0 12px 30px rgba(15,23,42,0.25);
      display: grid; grid-template-columns: 1.1fr 1fr; gap: 20px;
    }
    @media (max-width: 900px) { .app { grid-template-columns: 1fr; } }

    .panel, .preview {
      background: #f9fafb; border-radius: 12px;
      border: 1px solid #e5e7eb; padding: 14px 16px;
    }
    h1, h2 { margin: 0 0 0.5rem; }
    .meta { font-size: 0.85rem; color:#6b7280; margin-bottom: 0.5rem; }

    label { font-size:0.85rem; font-weight:600; display:block; margin-bottom:4px; }
    input[type="text"] {
      width: 100%; padding: 8px; border-radius: 8px;
      border: 1px solid #d1d5db; margin-bottom: 8px;
    }

    .btn {
      padding: 8px 14px; border-radius: 10px; border:none;
      background:#4f46e5; color:white; font-weight:600;
      cursor:pointer; font-size:0.9rem;
      box-shadow:0 6px 14px rgba(79,70,229,0.35);
    }
    .btn:disabled { opacity:0.5; box-shadow:none; cursor:default; }

    .question-block { margin-bottom: 10px; border-bottom:1px dashed #e5e7eb; padding-bottom:8px; }
    .question-title { font-weight:600; margin-bottom:4px; }
    .option-line { font-size:0.85rem; margin-left:12px; }

    .tag {
      display:inline-block; font-size:0.75rem;
      padding:2px 6px; border-radius:999px;
      background:#e5e7eb; margin-left:6px; margin-bottom:4px;
    }
    .tag-green {
      background:#dcfce7; color:#166534;
    }
    .tag-orange {
      background:#ffedd5; color:#9a3412;
    }
  </style>
</head>
<script>
const STORED_HASH = "7c376fc4dbe92142bcc71ed3b314301cf495e7d91d72c6d0252bae3550625a76";

if (localStorage.getItem("trainerAuth") !== REQUIRED_HASH) {
  window.location.href = "trainer-login.html";
}
</script>

<body>
<div class="app">
  <!-- LEFT: Builder controls -->
  <div>
    <h1>Quiz Builder (trainer)</h1>
    <p class="meta">
      Upload a questions file (.txt / .docx).<br>
      Optionally upload an answer key file (.txt / .docx).<br><br>
      • With answer key → MCQ questions are graded.<br>
      • Without answer key → MCQ questions are <strong>ungraded</strong> but options are kept.<br>
      • Questions without options → become short-answer questions.
    </p>

    <div class="panel">
      <label>Questions File (required)</label>
      <input id="questionsFile" type="file" accept=".txt,.docx" />

      <div style="margin-top:10px;">
        <label>Answer Key File (optional)</label>
        <input id="answersFile" type="file" accept=".txt,.docx" />
        <p class="meta" style="margin-top:4px;">
          If you skip this, MCQs will not be auto-graded.
        </p>
      </div>

      <label style="margin-top:10px;">Quiz Title</label>
      <input id="quizTitleInput" type="text" placeholder="e.g. Python Basics Quiz" />

      <label>Description (optional)</label>
      <input id="quizDescInput" type="text" placeholder="Short description" />

      <button id="loadBtn" class="btn" style="margin-top:10px;">Load Quiz</button>
      <p id="loadStatus" class="meta"></p>

      <button id="downloadBtn" class="btn" style="margin-top:10px;" disabled>
        Download Quiz JSON
      </button>
    </div>
  </div>

  <!-- RIGHT: Preview -->
  <div class="preview">
    <h2>Quiz Preview</h2>
    <p id="previewMeta" class="meta">No quiz loaded yet.</p>
    <div id="previewBody" style="max-height:400px; overflow:auto; font-size:0.9rem;">
      <p style="color:#6b7280;">Load a quiz to see a preview here.</p>
    </div>
  </div>
</div>

<script>
  let quizQuestions = []; // [{text, type: 'mcq'|'short', options:[], answerIndex: null|number}]

  // Read file (txt / docx)
  async function readFile(file) {
    if (file.name.toLowerCase().endsWith(".txt")) {
      return file.text();
    }
    if (file.name.toLowerCase().endsWith(".docx")) {
      const buffer = await file.arrayBuffer();
      const result = await mammoth.extractRawText({ arrayBuffer: buffer });
      return result.value;
    }
    throw new Error("Unsupported file type");
  }

  // Parse questions from text
  function parseQuestions(text) {
    const lines = text.split(/\r?\n/).map(l => l.trim());
    const questions = [];
    let current = null;

    function pushCurrent() {
      if (!current || !current.text) return;
      // type will be set later (MCQ/short) based on options + presence of answers
      questions.push(current);
    }

    for (const lineRaw of lines) {
      const line = lineRaw.trim();
      if (!line) continue;

      const qMatch = /^(\d+)[.)-]\s*(.+)$/.exec(line);      // "1. Question?"
      const optMatch = /^([A-D])[.)]\s*(.+)$/i.exec(line); // "A) Option" or "A. Option"

      if (qMatch) {
        pushCurrent();
        current = { text: qMatch[2].trim(), options: [], answerIndex: null };
      } else if (optMatch && current) {
        current.options.push(optMatch[2].trim());
      } else if (current) {
        current.text += " " + line;
      }
    }

    pushCurrent();
    return questions;
  }

  // Parse answers from answer key
  function parseAnswers(text) {
    const lines = text.split(/\r?\n/).map(l => l.trim());
    const answers = [];

    for (const line of lines) {
      const m = /^(\d+)[.)-]\s*([A-D])/i.exec(line);
      if (m) {
        const idx = "ABCD".indexOf(m[2].toUpperCase());
        if (idx !== -1) answers.push(idx);
      }
    }
    return answers;
  }

  // Attach answers to questions if answer key provided
  // questions: raw parsed questions with options[]
  // answers: array of indices 0-3 for A-D
  // hasAnswers: boolean (true if an answer file was uploaded and parsed)
  function finalizeQuestions(questions, answers, hasAnswers) {
    let ansIdx = 0;

    return questions.map(q => {
      const isMCQ = q.options && q.options.length > 0;

      if (isMCQ && hasAnswers && ansIdx < answers.length) {
        // Graded MCQ
        return {
          text: q.text,
          type: "mcq",
          options: q.options,
          answerIndex: answers[ansIdx++]  // store correct option
        };
      } else if (isMCQ && !hasAnswers) {
        // UNGRADED MCQ: keep options, but no correct answer
        return {
          text: q.text,
          type: "mcq",
          options: q.options,
          answerIndex: null               // Player will treat this as ungraded
        };
      } else {
        // Short-answer question (no options)
        return {
          text: q.text,
          type: "short",
          options: [],
          answerIndex: null
        };
      }
    });
  }

  // Render preview on right side
  function renderPreview() {
    const body = document.getElementById("previewBody");
    const meta = document.getElementById("previewMeta");

    if (!quizQuestions.length) {
      meta.textContent = "No quiz loaded.";
      body.innerHTML = "<p style='color:#6b7280;'>No questions.</p>";
      return;
    }

    const mcqCount = quizQuestions.filter(q => q.type === "mcq").length;
    const gradedMCQ = quizQuestions.filter(q => q.type === "mcq" && q.answerIndex !== null).length;
    const shortCount = quizQuestions.filter(q => q.type === "short").length;

    meta.textContent =
      `${quizQuestions.length} question(s): ${mcqCount} MCQ (${gradedMCQ} graded), ${shortCount} short-answer.`;

    body.innerHTML = "";

    quizQuestions.forEach((q, idx) => {
      const block = document.createElement("div");
      block.className = "question-block";

      const title = document.createElement("div");
      title.className = "question-title";
      title.textContent = `Q${idx + 1}. ${q.text}`;
      block.appendChild(title);

      const typeTag = document.createElement("span");
      typeTag.className = "tag";
      typeTag.textContent = (q.type === "mcq") ? "MCQ" : "Short answer";
      block.appendChild(typeTag);

      if (q.type === "mcq") {
        if (q.answerIndex !== null) {
          const gradedTag = document.createElement("span");
          gradedTag.className = "tag tag-green";
          gradedTag.textContent = "Graded";
          block.appendChild(gradedTag);
        } else {
          const ungradedTag = document.createElement("span");
          ungradedTag.className = "tag tag-orange";
          ungradedTag.textContent = "Ungraded (no answer key)";
          block.appendChild(ungradedTag);
        }

        q.options.forEach((opt, i) => {
          const line = document.createElement("div");
          line.className = "option-line";
          line.textContent = `${"ABCD"[i]}) ${opt}`;
          if (q.answerIndex === i) {
            const ansTag = document.createElement("span");
            ansTag.className = "tag tag-green";
            ansTag.textContent = "Correct";
            line.appendChild(ansTag);
          }
          block.appendChild(line);
        });
      } else {
        const info = document.createElement("div");
        info.className = "meta";
        info.textContent = "Short-answer: student will type their response.";
        block.appendChild(info);
      }

      body.appendChild(block);
    });
  }

  // Load button handler
  document.getElementById("loadBtn").onclick = async () => {
    const qFile = document.getElementById("questionsFile").files[0];
    const aFile = document.getElementById("answersFile").files[0];

    if (!qFile) {
      alert("Please choose a questions file.");
      return;
    }

    try {
      document.getElementById("loadStatus").textContent = "Reading file(s)...";

      // Read questions first
      const qText = await readFile(qFile);
      const rawQuestions = parseQuestions(qText);

      if (!rawQuestions.length) {
        alert("No questions detected in the questions file.");
        document.getElementById("loadStatus").textContent = "";
        return;
      }

      let answers = [];
      let hasAnswers = false;

      if (aFile) {
        try {
          const aText = await readFile(aFile);
          answers = parseAnswers(aText);
          hasAnswers = answers.length > 0;
          if (!hasAnswers) {
            alert("No valid answers detected in answer key file. MCQs will be ungraded.");
          }
        } catch (err) {
          console.warn("Failed to parse answers:", err);
          alert("Could not parse answer key. MCQs will be ungraded.");
          hasAnswers = false;
        }
      } else {
        // No answer file uploaded
        hasAnswers = false;
      }

      quizQuestions = finalizeQuestions(rawQuestions, answers, hasAnswers);
      renderPreview();
      document.getElementById("loadStatus").textContent =
        hasAnswers
          ? "Quiz loaded with graded MCQs."
          : "Quiz loaded (MCQs ungraded, no answer key).";
      document.getElementById("downloadBtn").disabled = false;

    } catch (e) {
      console.error(e);
      alert("Failed to read or parse file(s).");
      document.getElementById("loadStatus").textContent = "";
    }
  };

  // Download JSON button handler
  document.getElementById("downloadBtn").onclick = () => {
    if (!quizQuestions.length) {
      alert("Load a quiz first.");
      return;
    }

    const title = document.getElementById("quizTitleInput").value.trim() || "Untitled Quiz";
    const desc  = document.getElementById("quizDescInput").value.trim();

    const quizData = {
      title,
      description: desc,
      questions: quizQuestions
    };

    const blob = new Blob([JSON.stringify(quizData, null, 2)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    const safeName = title.toLowerCase().replace(/[^a-z0-9]+/g, "_");
    a.href = url;
    a.download = safeName + ".json";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };
</script>
</body>
</html>
